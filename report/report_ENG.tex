\documentclass[12pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{amsmath,amssymb,mathtools}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\geometry{margin=2.5cm}

\title{Academic Report \\ ECDSA-Blockchain Project}
\author{Course: Institutions of Algebra and Geometry \\ Master's Degree in Applied Mathematics}
\date{}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Abstract}
This report provides a rigorous description of an educational blockchain inspired by Ethereum,
with special attention to the cryptographic foundations (ECDSA on secp256k1),
the data modeling, and the consensus rules implemented in the codebase.
It also analyzes a real attack (\emph{weak nonce reuse}) showing how an error in the
cryptographic nonce compromises the entire signature scheme.
The document constantly links theory to code: every phase (key generation,
transaction creation, mining, synchronization, attack) is grounded in the
corresponding software components.

\section{Project goals}
The project focuses on four main goals:
\begin{enumerate}
  \item Understand the fundamental operations of an account-based blockchain.
  \item Study ECDSA with emphasis on the role of the nonce $k$.
  \item Demonstrate a concrete vulnerability caused by nonce reuse.
  \item Connect linear algebra, group theory, and protocol security.
\end{enumerate}

\section{Cryptographic foundations and elliptic curves}
\subsection{secp256k1 curve and keys}
We work over the finite field $\mathbb{F}_p$ and the secp256k1 curve:
\[
E: y^2 \equiv x^3 + 7 \pmod p.
\]
The \emph{private} key is an integer $d \in \{1,\dots,n-1\}$,
while the public key is the point $Q = dG$ in the group generated by $G$.
In the code, keypair generation is handled by functions that return a private
key and a compressed public key (module \texttt{minichain/crypto.py}).

\subsection{Address derivation}
The address is not the full public key but a derived identifier:
we compute Keccak-256 of the uncompressed public key (excluding the prefix byte),
then take the last 20 bytes.
This scheme is implemented explicitly in software
(module \texttt{minichain/crypto.py}, function \texttt{pubkey\_to\_address}).

\subsection{ECDSA signatures}
Given a message digest $z$, ECDSA defines:
\[
R = kG, \quad r = x_R \bmod n, \quad s = k^{-1}(z + rd) \bmod n.
\]
Verification reconstructs the point $X = u_1 G + u_2 Q$ with
$u_1 = zs^{-1}$ and $u_2 = rs^{-1}$.
In implementation terms, the transaction digest is SHA-256 of a canonical JSON
(module \texttt{minichain/utils.py}), and signing is handled in \texttt{minichain/crypto.py}
via DER conversion or recoverable signatures.

\section{Data model: transactions and blocks}
\subsection{Transaction}
A transaction is modeled with a deterministic payload (without signature) and a separate signature.
The essential fields are:
\begin{itemize}
  \item recipient \texttt{to},
  \item value \texttt{value},
  \item account nonce \texttt{nonce},
  \item timestamp,
  \item sender public key,
  \item optional data.
\end{itemize}
The structure is defined in \texttt{minichain/models.py}, where the method
\texttt{payload\_dict} ensures deterministic serialization (crucial for signing and verification).

\subsection{Block}
A block contains a header (index, timestamp, list of transactions, previous hash,
difficulty, PoW nonce, and proposer) and its own hash. This structure is also defined
in \texttt{minichain/models.py}. The method \texttt{header\_dict} produces the
serialized content that is then hashed with SHA-256.

\section{Canonical serialization and hashing}
The code enforces canonical JSON serialization: sorted keys, compact separators,
UTF-8. This removes ambiguity in the representation of data to be signed.
The function \texttt{canonical\_json} in \texttt{minichain/utils.py} implements this rule.
A transaction digest is SHA-256 of the serialized payload,
while address derivation uses Keccak-256, consistent with Ethereum.

\section{Global state and validation rules}
\subsection{Account model}
The project adopts an account model: the global state is a map
\(\Sigma_t: \text{address} \mapsto (\text{balance},\text{nonce})\).
This map is maintained in \texttt{minichain/chain.py}.

\subsection{Genesis}
The file \texttt{genesis.json} defines the initial allocation of accounts.
The node loads the allocation and resets the state based on it.
Genesis creation is implemented in \texttt{scripts/create\_genesis.py},
which reads wallets and assigns initial balances.

\subsection{Transaction validation}
The main rules are:
\begin{enumerate}[label=\textbf{R\arabic*.}]
  \item positive amount,
  \item valid destination address,
  \item valid ECDSA signature and recoverable sender,
  \item nonce exactly equal to the current account nonce,
  \item sufficient balance.
\end{enumerate}
These rules are implemented in \texttt{check\_tx\_rules} and
\texttt{verify\_sender} in \texttt{minichain/chain.py}.

\subsection{Applying a transaction}
A valid transaction updates the state: the sender balance decreases,
the recipient is credited, and the sender nonce increments. This is handled
by \texttt{apply\_tx} in \texttt{minichain/chain.py}.

\section{Mining and Proof-of-Work}
\subsection{PoW definition}
Mining consists in finding a nonce $n_{pow}$ such that the block hash
starts with a prefix of hexadecimal zeros equal to the difficulty.
With difficulty $d$, the success probability per attempt is
$16^{-d}$ and expected attempts are $16^d$.

\subsection{Implemented algorithm}
In the code:
\begin{enumerate}
  \item a candidate block is built from mempool tx (\texttt{make\_candidate\_block});
  \item PoW is attempted by incrementing the nonce (\texttt{mine\_block});
  \item if the block is valid, it is added and tx are removed from the mempool
  (\texttt{add\_block}).
\end{enumerate}
Difficulty and an optional reward are configurable in \texttt{ChainConfig}.

\section{Node, network, and synchronization}
\subsection{REST API}
The node is a Flask service exposing APIs for:
\begin{itemize}
  \item identity and state (\texttt{/identity}, \texttt{/chain}),
  \item balance and nonce queries (\texttt{/balance/<addr>}, \texttt{/nonce/<addr>}),
  \item transaction submission (\texttt{/tx/new} and \texttt{/local/make\_tx}),
  \item mining (\texttt{/mine}),
  \item block propagation (\texttt{/block/new}),
  \item longest-chain synchronization (\texttt{/sync}).
\end{itemize}
Implementation lives in \texttt{minichain/node.py}.

\subsection{Persistence}
Each node persists the chain and account state in \texttt{data/node\_<PORT>/state.json}.
Atomic read/write is centralized in \texttt{minichain/storage.py}.

\section{CLI scripts and educational tooling}
The project provides Python scripts to manage the full lifecycle:
\begin{itemize}
  \item \texttt{scripts/create\_wallet.py}: generate a wallet (keys and address).
  \item \texttt{scripts/create\_genesis.py}: build a genesis allocation.
  \item \texttt{scripts/send\_tx.py}: sign and submit a standard transaction.
  \item \texttt{scripts/run\_node\_safe.py} (launcher): start a node with parameters.
\end{itemize}
These tools make the laboratory experiment reproducible and reduce operational friction.

\section{Weak Nonce Reuse attack}
\subsection{Mathematical idea}
If two ECDSA signatures use the same nonce $k$, they share the same $r$.
Given two pairs $(r,s_1)$ and $(r,s_2)$ with message digests $z_1,z_2$:
\[
  k = (z_1 - z_2)(s_1 - s_2)^{-1} \bmod n,
\]
\[
  d = (s_1 k - z_1) r^{-1} \bmod n.
\]
Reusing $k$ thus reveals the private key $d$.

\subsection{Attack implementation}
The script \texttt{attacks/weak\_nonce/make\_weak\_txs.py} signs two different
transactions with the same nonce $k$ and sends them to the node; the transactions
are saved as JSON. The script \texttt{attacks/weak\_nonce/recover\_privkey.py} loads
those tx, reconstructs $k$, and computes the private key. The same logic is integrated
in the red webapp (\texttt{webapp/weak\_nonce\_app.py}), which scans chain and mempool
looking for signatures with the same $r$.

\section{Web interfaces}
\subsection{User console}
The user web console (\texttt{webapp/app.py}) provides an interface to send transactions,
mine blocks, and query balances. In educational mode, a button is available to generate
\emph{weak tx} that deliberately reuse the nonce $k$.

\subsection{Attacker console}
The red console (\texttt{webapp/weak\_nonce\_app.py}) scans the blockchain state
and attempts private-key recovery when signatures share the same $r$.

\section{Conclusions}
The project shows that a blockchain is not only a distributed protocol,
but a delicate interaction between algebra, cryptography, and software engineering.
Correct consensus rules are not sufficient if cryptographic signing is implemented
in a vulnerable way. The nonce-reuse case demonstrates a deterministic and reproducible
attack that directly links theory and practice.

\end{document}
